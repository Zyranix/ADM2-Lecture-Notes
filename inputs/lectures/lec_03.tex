%! TEX root = ../../master.tex
\lecture[Hardness. Decision problems.]{Di 26 Apr 2022}{Hardness}


\section{Hardness}
We cheat and restrict hardness to \emph{decision problems}, that is, problems
that can be answered by "Yes" or "No" only.
\begin{example} Possible decision problems could be:
    \begin{enumerate}
        \item Does there exist a Hamiltonian cycle?
        \item Is the LP feasible?
    \end{enumerate}
\end{example}
\begin{question}
    How do we model an optimization problem as an decision problem?
\end{question}
\begin{answer}
    We can simply introduce a parameter $z$ which we use as a bound for the value we want to optimize.
\end{answer}
\begin{example} Possible reformulations of optimization problems are therefore:
    \begin{enumerate}
        \item Does there exist a feasible $x$ with $c^Tx \leq z$?
        \item Does there exist a spanning tree with cost less than $z$?
        \item Is there a clique with size less than $z$?
    \end{enumerate}
\end{example}
\begin{definition}
    A \vocab{clique} $C$ is a subset of nodes $V$ of a graph $G=(V,E)$ s.t.
    for all $i,j \in C$ it must hold true that $(i,j)\in E$.
\end{definition}
\begin{theorem}
    When we model an optimization problem as a decision problem, then there exist
    a oracle-polynomial way to solve the optimization problem using the decision problem
    as an oracle.
\end{theorem}
\begin{algorithm}[H]
    \SetAlgoLined
    Use binary search to find $z^*$ in $\mathcal{O}(\log n)$\\
    $G' \leftarrow G = (V,E)$\\
    \For{$i=1,...,n$}{
        $G'' \leftarrow G'$, but remove all edges incident to node $i$\\
        \If{Call of decision oracle on $G'',z^*$ is true}{
            $G' \leftarrow G''$\\
        }
    }
    %  reindeer $\leftarrow$ 0\tcp*{current position of reindeer} 
    \caption{Oracle-polynomial algorithm for max-clique}
\end{algorithm} \noindent

\begin{theorem}
    Final $\overline{G} \coloneqq  G'$ is a max-clique.
\end{theorem}
\begin{proof}
    The size of a max clique in $G'$ never goes below $z^*$.
    Therefore, there exists a clique $C \subset \overline{G}$ with $|C|=z^*$.
    Suppose $\overline{G}$ has more than $z^*$ nodes. Then $i \in \overline{G} \setminus C$.
    But then the algorithm would have deleted this node!
\end{proof}
\begin{corollary}
    If we have an optimal oracle, then one can solve decision version in oracle-polynomial time using the optimal oracle.
\end{corollary}
\begin{conclusion}
    Optimization and decision version differ only by a polynomial factor of complexity.
    Therefore, either both are easy or both are hard.
\end{conclusion}
\begin{definition}[Certificate]
    Given an instance of any problem with size $n$,
    a \vocab{certificate} is a binary-encoded string that is generated by some algorithm specific to the problem, taking the instance as input.
    We say the certificate is a \vocab[certificate!succinct]{succinct certificate}, if its \emph{length} is polynomial in the input size $n$.
\end{definition}
\begin{definition}[$\NP$]
    We say a (decision) problem $P$ lies in \vocab[NP]{$\NP$},
    if for all Yes-instances $I$ there exists a succinct certificate $C$
    and a certificate checking algorithm $A$ that confirms $A(I,C)$ in polynomial time.
\end{definition}
\begin{theorem}
    Max-clique lies in $\mathbf{NP}$
\end{theorem}
\begin{proof}
    We use our clique $C$ directly as the certificate.\\
    \begin{algorithm}[H]
        \SetAlgoLined
        \If{$|C|<z$}{
            return \texttt{NO}\\
        } \Else{
            \For{$i,j \in C$}{
                \If{$(i,j) \not \in E$}{
                    return \texttt{NO}\\
                }
            }
        }
        return \texttt{YES}\\
        \caption{Certificate checking for max-clique}
    \end{algorithm} \noindent
\end{proof}
\begin{remark}
    Note that we don't care for No-instances! In order to verify them we would need to
    list all $\binom{n}{z}$ subsets (for max-clique), which is \emph{not} polynomial.
\end{remark}
\begin{theorem}
    $\mathbf{P} \subset \mathbf{NP}$
\end{theorem}
\begin{proof}
    Let $P\in \mathbf{P}$. Then there exists a polynomial algorithm $A$.
    Record the steps of A on an instance $I$ and use this as a polynomial certificate.
\end{proof}
\begin{theorem}
    $\mathsf{LP} \in \mathbf{NP}$, using decision variant if there is any feasible $x$.
\end{theorem}
\begin{proof}
    If feasible, there exists a basic feasible solution $x^*$.
    We verify by checking $Bx^*=b$. One can show that $x^*$ has polynomial bits.
\end{proof}
Let's also have a look at the canonical $\mathbf{NP}$ problem:
\begin{definition}[Satisfiability problem, $\mathsf{SAT}$]
    Consider $n$ logical variables $v_1,...,v_n$,
    allowing also the negated literals $\overline{v_i}$.
    Additionally, we have $m$ clauses $C_1,...,C_m$, which are subsets of the literals.
    Determining if there is an assignment such that the overall clause is true (i.e. each subclause has at least one true literal)
    is known as the \vocab{satisfiability problem}, for short $\SAT$.
\end{definition}
\begin{example} A few examples: \label{ex:SAT_formulas}
    \begin{enumerate}
        \item $(v_1 \OR v_2 \OR v_3) \AND (\overline{v_1} \OR \overline{v_2} \OR \overline{v_3})$\\
              This instance is true for $v=(110)$.
        \item $(v_1 \OR v_2) \AND (\overline{v_1} \OR v_2) \AND (\overline{v_2} \OR v_3) \AND (\overline{v_3} \OR \overline{v_4})$\\
              One can check that this instance is always false.
    \end{enumerate}
\end{example}
\begin{theorem}
    $\mathsf{SAT} \in \mathbf{NP}$
\end{theorem}
\begin{proof}
    The satisfiability truth assignment is a succinct certificate.
\end{proof}
\begin{theorem}[Cook]
    If $P\in \mathbf{NP}$, then $P$ has an oracle-polynomial algorithm with $\mathsf{SAT}$ as an oracle.
\end{theorem}
\begin{proof}
    Suppose $P \in \mathbf{NP}$, then $P$ has a non-deterministic Turing Machine with polynomial size.
\end{proof}